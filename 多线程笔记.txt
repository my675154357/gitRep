1.进程：进程是指正在运行的程序。当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并具有一定独立功能。
2.分时调度：所有线程平均分配使用cpu资源
  抢占调度：根据优先级进行调度，优先级高的获取cpu的资源就多，就会多占用cpu一些时间。
3.wait()和notify()、notifyAll()是Object类的方法。Object也在lang包下
4.关于权限：
 * 默认权限：本包可用
 * pvivate：本类私用
 * public：外包可用
 * protected：子包专用
 5.因为线程创建和销毁的开销非常大，可能比执行任务的开销都大，因此，会使用到线程池的技术
 线程池原理：程序会在开始时创建多个线程对象存储到集合中，需要线程的时候就从集合中获取。
 Thread t = array.remove(0);这样连移除带返回一起做了。
 使用完毕后不能让线程销毁，要再添加到集合中，add(t);
 从JDK开始就内置线程池技术，直接使用。之前都是程序员自己实现线程池的。
 6.使用线程池方式 - 实现runable接口
 	通常线程池都是有线程池工厂创建的，在调用线程池的方法获取线程，再通过线程去执行任务方法。
 java.util.concurrent包下有个Executors类，线程池创建工厂类，使用它的静态方法创建。
 static ExecutorService new FixedThreadPool(int threads); 返回的是ExecutorService的实现类（是一个线程池对象）。
 接着调用线程池对象的submit(Runable r) 提交线程执行任务。可以使用shutdown()销毁线程池。但一般不用。
 但实现runable接口的方式也有缺点，run()方法没有返回也不能抛异常。所以，可以这么做：
 在java.util.concurrent包下有个Callable接口，里面有个call()方法，它可以有返回值也可以抛异常，而线程池的submit()不光可以接受Runable的实现类，也可以接受Callable的实现类，这是极好的。

 7.多个线程同时操作一个共享数据，往往会出现共享问题。明白的讲就是，一个线程实现类中的run()或者call()方法，被多个线程执行，那么方法中的数据可能会出现安全问题。

 8.synchronized(任意对象){线程压要操作的共享数据} 。 synchronized (obj){}。obj这个对象称为“同步锁”，也叫做“对象监视器”。
 同步安全保证的原因：没有锁的线程不能执行，只能等待。
 Thread.sleep();方法不会放弃同步锁，但是线程0在sleep()的时候，其他线程是有机会获取到CPU资源运行的，但是其他线程在走到同步代码块的时候会先去判断有没有对象锁，而此时对象锁还被线程0持有，所以其他线程走到这并不能执行同步代码块，只能等线程0执行完放弃对象锁。

 9.死锁出现的前提：
 a.必须是多线程
 b.出现同步嵌套

 关于死锁的一点理解：
 	如果有两个同步代码块：A和B。
 	此时有两个线程：线程0和线程1。
 	线程0中是在同步块A中嵌套了同步块B，线程1是在同步块B中嵌套了同步块A。
 	当线程0执行的时候首先获取了同步块A的对象锁，而此时线程1可能也在执行获取了同步块B的对象锁。此时线程0想执行嵌套内部的同步块B时首先要获得同步块B的锁，但是B的锁被线程1获得了。那么线程0就只有等待B锁被释放，线程0仍然持有A锁；与此同时，线程1要执行内部嵌套的同步块A时，需要先获取A锁，但是A锁还被线程0持有，那么线程1就只能等待A锁被释放，此时线程1仍然持有着B锁。结果，就造成线程0等待线程1，线程1等待线程0，双方都不撒手，陷入无尽的等待永远、永远...如果这是恋爱的话，无疑是可以天长地久的，是都希望看到的结果。但是在程序里是绝不能行的，必须有一方撒手，程序才能继续执行。
